// Code generated by fabrica generate. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file provides storage convenience functions for your resources.
// It uses the fabrica storage backend system.
//
// To modify storage behavior:
//  1. Edit pkg/codegen/templates/storage.go.tmpl
//  2. Run 'fabrica generate' to regenerate
//
// To change storage backend:
//  1. Call storage.Init() with a different backend in main.go
//  2. Options: FileBackend, EntBackend (database), or custom backend
package storage

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/openchami/fabrica/pkg/reconcile"
	fabricaStorage "github.com/openchami/fabrica/pkg/storage"

	"github.com/openchami/boot-service/pkg/resources/bmc"
	"github.com/openchami/boot-service/pkg/resources/bootconfiguration"
	"github.com/openchami/boot-service/pkg/resources/node"
)

// Backend is the storage backend used by all storage operations.
// Initialize this in your main.go before using any storage functions.
//
// Example:
//
//	backend, err := fabricaStorage.NewFileBackend("./data")
//	if err != nil {
//	    log.Fatal(err)
//	}
//	storage.Init(backend)
var Backend fabricaStorage.StorageBackend

// Init initializes the storage backend.
// This must be called before using any storage functions.
func Init(backend fabricaStorage.StorageBackend) {
	Backend = backend
}

// InitFileBackend is a convenience function to initialize file-based storage.
// It creates the directory if it doesn't exist.
func InitFileBackend(dataDir string) error {
	backend, err := fabricaStorage.NewFileBackend(dataDir)
	if err != nil {
		return fmt.Errorf("failed to create file backend: %w", err)
	}
	Backend = backend
	return nil
}

// ensureBackend panics if Backend is not initialized.
// This is called by all storage functions to ensure proper initialization.
func ensureBackend() {
	if Backend == nil {
		panic("storage backend not initialized: call storage.Init() or storage.InitFileBackend() in main.go")
	}
}

// BMC storage operations

// LoadAllBMCs retrieves all BMC resources.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//
// Returns:
//   - []*bmc.BMC: Slice of BMC resources
//   - error: Any error that occurred during loading
func LoadAllBMCs(ctx context.Context) ([]*bmc.BMC, error) {
	ensureBackend()

	rawData, err := Backend.LoadAll(ctx, "BMC")
	if err != nil {
		return nil, fmt.Errorf("failed to load all bmcs: %w", err)
	}

	bmcs := make([]*bmc.BMC, 0, len(rawData))
	for _, raw := range rawData {
		bMC := &bmc.BMC{}
		if err := json.Unmarshal(raw, bMC); err != nil {
			return nil, fmt.Errorf("failed to unmarshal BMC: %w", err)
		}
		bmcs = append(bmcs, bMC)
	}

	return bmcs, nil
}

// LoadBMC retrieves a single BMC resource by UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the BMC resource
//
// Returns:
//   - *bmc.BMC: The BMC resource
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func LoadBMC(ctx context.Context, uid string) (*bmc.BMC, error) {
	ensureBackend()

	rawData, err := Backend.Load(ctx, "BMC", uid)
	if err != nil {
		return nil, fmt.Errorf("failed to load BMC %s: %w", uid, err)
	}

	bMC := &bmc.BMC{}
	if err := json.Unmarshal(rawData, bMC); err != nil {
		return nil, fmt.Errorf("failed to unmarshal BMC: %w", err)
	}

	return bMC, nil
}

// SaveBMC stores a BMC resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - bMC: The BMC resource to save
//
// Returns:
//   - error: Any error that occurred during saving
func SaveBMC(ctx context.Context, bMC *bmc.BMC) error {
	ensureBackend()

	data, err := json.Marshal(bMC)
	if err != nil {
		return fmt.Errorf("failed to marshal BMC: %w", err)
	}

	if err := Backend.Save(ctx, "BMC", bMC.Metadata.UID, data); err != nil {
		return fmt.Errorf("failed to save BMC: %w", err)
	}

	return nil
}

// UpdateBMC updates an existing BMC resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - bMC: The BMC resource to update
//
// Returns:
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func UpdateBMC(ctx context.Context, bMC *bmc.BMC) error {
	ensureBackend()

	// Check if resource exists first
	exists, err := Backend.Exists(ctx, "BMC", bMC.Metadata.UID)
	if err != nil {
		return fmt.Errorf("failed to check BMC existence: %w", err)
	}
	if !exists {
		return fabricaStorage.ErrNotFound
	}

	data, err := json.Marshal(bMC)
	if err != nil {
		return fmt.Errorf("failed to marshal BMC: %w", err)
	}

	if err := Backend.Save(ctx, "BMC", bMC.Metadata.UID, data); err != nil {
		return fmt.Errorf("failed to update BMC: %w", err)
	}

	return nil
}

// DeleteBMC removes a BMC resource by UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the BMC resource
//
// Returns:
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func DeleteBMC(ctx context.Context, uid string) error {
	ensureBackend()

	if err := Backend.Delete(ctx, "BMC", uid); err != nil {
		return fmt.Errorf("failed to delete BMC %s: %w", uid, err)
	}

	return nil
}

// ExistsBMC checks if a BMC resource exists.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the BMC resource
//
// Returns:
//   - bool: true if the resource exists
//   - error: Any error that occurred during the check
func ExistsBMC(ctx context.Context, uid string) (bool, error) {
	ensureBackend()

	exists, err := Backend.Exists(ctx, "BMC", uid)
	if err != nil {
		return false, fmt.Errorf("failed to check BMC existence: %w", err)
	}

	return exists, nil
}

// ListBMCUIDs returns UIDs of all BMC resources.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//
// Returns:
//   - []string: Array of BMC resource UIDs
//   - error: Any error that occurred during listing
func ListBMCUIDs(ctx context.Context) ([]string, error) {
	ensureBackend()

	uids, err := Backend.List(ctx, "BMC")
	if err != nil {
		return nil, fmt.Errorf("failed to list BMC UIDs: %w", err)
	}

	return uids, nil
}

// BootConfiguration storage operations

// LoadAllBootConfigurations retrieves all BootConfiguration resources.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//
// Returns:
//   - []*bootconfiguration.BootConfiguration: Slice of BootConfiguration resources
//   - error: Any error that occurred during loading
func LoadAllBootConfigurations(ctx context.Context) ([]*bootconfiguration.BootConfiguration, error) {
	ensureBackend()

	rawData, err := Backend.LoadAll(ctx, "BootConfiguration")
	if err != nil {
		return nil, fmt.Errorf("failed to load all bootconfigurations: %w", err)
	}

	bootconfigurations := make([]*bootconfiguration.BootConfiguration, 0, len(rawData))
	for _, raw := range rawData {
		bootConfiguration := &bootconfiguration.BootConfiguration{}
		if err := json.Unmarshal(raw, bootConfiguration); err != nil {
			return nil, fmt.Errorf("failed to unmarshal BootConfiguration: %w", err)
		}
		bootconfigurations = append(bootconfigurations, bootConfiguration)
	}

	return bootconfigurations, nil
}

// LoadBootConfiguration retrieves a single BootConfiguration resource by UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the BootConfiguration resource
//
// Returns:
//   - *bootconfiguration.BootConfiguration: The BootConfiguration resource
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func LoadBootConfiguration(ctx context.Context, uid string) (*bootconfiguration.BootConfiguration, error) {
	ensureBackend()

	rawData, err := Backend.Load(ctx, "BootConfiguration", uid)
	if err != nil {
		return nil, fmt.Errorf("failed to load BootConfiguration %s: %w", uid, err)
	}

	bootConfiguration := &bootconfiguration.BootConfiguration{}
	if err := json.Unmarshal(rawData, bootConfiguration); err != nil {
		return nil, fmt.Errorf("failed to unmarshal BootConfiguration: %w", err)
	}

	return bootConfiguration, nil
}

// SaveBootConfiguration stores a BootConfiguration resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - bootConfiguration: The BootConfiguration resource to save
//
// Returns:
//   - error: Any error that occurred during saving
func SaveBootConfiguration(ctx context.Context, bootConfiguration *bootconfiguration.BootConfiguration) error {
	ensureBackend()

	data, err := json.Marshal(bootConfiguration)
	if err != nil {
		return fmt.Errorf("failed to marshal BootConfiguration: %w", err)
	}

	if err := Backend.Save(ctx, "BootConfiguration", bootConfiguration.Metadata.UID, data); err != nil {
		return fmt.Errorf("failed to save BootConfiguration: %w", err)
	}

	return nil
}

// UpdateBootConfiguration updates an existing BootConfiguration resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - bootConfiguration: The BootConfiguration resource to update
//
// Returns:
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func UpdateBootConfiguration(ctx context.Context, bootConfiguration *bootconfiguration.BootConfiguration) error {
	ensureBackend()

	// Check if resource exists first
	exists, err := Backend.Exists(ctx, "BootConfiguration", bootConfiguration.Metadata.UID)
	if err != nil {
		return fmt.Errorf("failed to check BootConfiguration existence: %w", err)
	}
	if !exists {
		return fabricaStorage.ErrNotFound
	}

	data, err := json.Marshal(bootConfiguration)
	if err != nil {
		return fmt.Errorf("failed to marshal BootConfiguration: %w", err)
	}

	if err := Backend.Save(ctx, "BootConfiguration", bootConfiguration.Metadata.UID, data); err != nil {
		return fmt.Errorf("failed to update BootConfiguration: %w", err)
	}

	return nil
}

// DeleteBootConfiguration removes a BootConfiguration resource by UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the BootConfiguration resource
//
// Returns:
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func DeleteBootConfiguration(ctx context.Context, uid string) error {
	ensureBackend()

	if err := Backend.Delete(ctx, "BootConfiguration", uid); err != nil {
		return fmt.Errorf("failed to delete BootConfiguration %s: %w", uid, err)
	}

	return nil
}

// ExistsBootConfiguration checks if a BootConfiguration resource exists.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the BootConfiguration resource
//
// Returns:
//   - bool: true if the resource exists
//   - error: Any error that occurred during the check
func ExistsBootConfiguration(ctx context.Context, uid string) (bool, error) {
	ensureBackend()

	exists, err := Backend.Exists(ctx, "BootConfiguration", uid)
	if err != nil {
		return false, fmt.Errorf("failed to check BootConfiguration existence: %w", err)
	}

	return exists, nil
}

// ListBootConfigurationUIDs returns UIDs of all BootConfiguration resources.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//
// Returns:
//   - []string: Array of BootConfiguration resource UIDs
//   - error: Any error that occurred during listing
func ListBootConfigurationUIDs(ctx context.Context) ([]string, error) {
	ensureBackend()

	uids, err := Backend.List(ctx, "BootConfiguration")
	if err != nil {
		return nil, fmt.Errorf("failed to list BootConfiguration UIDs: %w", err)
	}

	return uids, nil
}

// Node storage operations

// LoadAllNodes retrieves all Node resources.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//
// Returns:
//   - []*node.Node: Slice of Node resources
//   - error: Any error that occurred during loading
func LoadAllNodes(ctx context.Context) ([]*node.Node, error) {
	ensureBackend()

	rawData, err := Backend.LoadAll(ctx, "Node")
	if err != nil {
		return nil, fmt.Errorf("failed to load all nodes: %w", err)
	}

	nodes := make([]*node.Node, 0, len(rawData))
	for _, raw := range rawData {
		node := &node.Node{}
		if err := json.Unmarshal(raw, node); err != nil {
			return nil, fmt.Errorf("failed to unmarshal Node: %w", err)
		}
		nodes = append(nodes, node)
	}

	return nodes, nil
}

// LoadNode retrieves a single Node resource by UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the Node resource
//
// Returns:
//   - *node.Node: The Node resource
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func LoadNode(ctx context.Context, uid string) (*node.Node, error) {
	ensureBackend()

	rawData, err := Backend.Load(ctx, "Node", uid)
	if err != nil {
		return nil, fmt.Errorf("failed to load Node %s: %w", uid, err)
	}

	node := &node.Node{}
	if err := json.Unmarshal(rawData, node); err != nil {
		return nil, fmt.Errorf("failed to unmarshal Node: %w", err)
	}

	return node, nil
}

// SaveNode stores a Node resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - node: The Node resource to save
//
// Returns:
//   - error: Any error that occurred during saving
func SaveNode(ctx context.Context, node *node.Node) error {
	ensureBackend()

	data, err := json.Marshal(node)
	if err != nil {
		return fmt.Errorf("failed to marshal Node: %w", err)
	}

	if err := Backend.Save(ctx, "Node", node.Metadata.UID, data); err != nil {
		return fmt.Errorf("failed to save Node: %w", err)
	}

	return nil
}

// UpdateNode updates an existing Node resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - node: The Node resource to update
//
// Returns:
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func UpdateNode(ctx context.Context, node *node.Node) error {
	ensureBackend()

	// Check if resource exists first
	exists, err := Backend.Exists(ctx, "Node", node.Metadata.UID)
	if err != nil {
		return fmt.Errorf("failed to check Node existence: %w", err)
	}
	if !exists {
		return fabricaStorage.ErrNotFound
	}

	data, err := json.Marshal(node)
	if err != nil {
		return fmt.Errorf("failed to marshal Node: %w", err)
	}

	if err := Backend.Save(ctx, "Node", node.Metadata.UID, data); err != nil {
		return fmt.Errorf("failed to update Node: %w", err)
	}

	return nil
}

// DeleteNode removes a Node resource by UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the Node resource
//
// Returns:
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func DeleteNode(ctx context.Context, uid string) error {
	ensureBackend()

	if err := Backend.Delete(ctx, "Node", uid); err != nil {
		return fmt.Errorf("failed to delete Node %s: %w", uid, err)
	}

	return nil
}

// ExistsNode checks if a Node resource exists.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the Node resource
//
// Returns:
//   - bool: true if the resource exists
//   - error: Any error that occurred during the check
func ExistsNode(ctx context.Context, uid string) (bool, error) {
	ensureBackend()

	exists, err := Backend.Exists(ctx, "Node", uid)
	if err != nil {
		return false, fmt.Errorf("failed to check Node existence: %w", err)
	}

	return exists, nil
}

// ListNodeUIDs returns UIDs of all Node resources.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//
// Returns:
//   - []string: Array of Node resource UIDs
//   - error: Any error that occurred during listing
func ListNodeUIDs(ctx context.Context) ([]string, error) {
	ensureBackend()

	uids, err := Backend.List(ctx, "Node")
	if err != nil {
		return nil, fmt.Errorf("failed to list Node UIDs: %w", err)
	}

	return uids, nil
}

// StorageClient wraps a StorageBackend to implement reconcile.ClientInterface.
//
// This adapter allows reconcilers to use the storage backend through a
// standard interface that provides typed resource access.
type StorageClient struct {
	backend fabricaStorage.StorageBackend
}

// Compile-time check that StorageClient implements reconcile.ClientInterface
var _ reconcile.ClientInterface = (*StorageClient)(nil)

// NewStorageClient creates a new storage client that wraps the configured backend.
//
// This is used by the reconciliation system to provide reconcilers with
// access to resource storage.
//
// Returns:
//   - *StorageClient: Client that implements reconcile.ClientInterface
func NewStorageClient() *StorageClient {
	ensureBackend()
	return &StorageClient{backend: Backend}
}

// Get retrieves a resource by kind and UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - kind: Resource kind (e.g., "Device", "Rack")
//   - uid: Unique identifier
//
// Returns:
//   - interface{}: The resource (type-specific)
//   - error: Any error that occurred
func (c *StorageClient) Get(ctx context.Context, kind, uid string) (interface{}, error) {
	rawData, err := c.backend.Load(ctx, kind, uid)
	if err != nil {
		return nil, err
	}

	// Unmarshal based on kind
	switch kind {
	case "BMC":
		var resource bmc.BMC
		if err := json.Unmarshal(rawData, &resource); err != nil {
			return nil, fmt.Errorf("failed to unmarshal BMC: %w", err)
		}
		return &resource, nil
	case "BootConfiguration":
		var resource bootconfiguration.BootConfiguration
		if err := json.Unmarshal(rawData, &resource); err != nil {
			return nil, fmt.Errorf("failed to unmarshal BootConfiguration: %w", err)
		}
		return &resource, nil
	case "Node":
		var resource node.Node
		if err := json.Unmarshal(rawData, &resource); err != nil {
			return nil, fmt.Errorf("failed to unmarshal Node: %w", err)
		}
		return &resource, nil
	default:
		return nil, fmt.Errorf("unknown resource kind: %s", kind)
	}
}

// List retrieves all resources of a given kind.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - kind: Resource kind (e.g., "Device", "Rack")
//
// Returns:
//   - []interface{}: Slice of resources
//   - error: Any error that occurred
func (c *StorageClient) List(ctx context.Context, kind string) ([]interface{}, error) {
	rawData, err := c.backend.LoadAll(ctx, kind)
	if err != nil {
		return nil, err
	}

	// Unmarshal based on kind
	switch kind {
	case "BMC":
		result := make([]interface{}, 0, len(rawData))
		for _, raw := range rawData {
			var resource bmc.BMC
			if err := json.Unmarshal(raw, &resource); err != nil {
				return nil, fmt.Errorf("failed to unmarshal BMC: %w", err)
			}
			result = append(result, &resource)
		}
		return result, nil
	case "BootConfiguration":
		result := make([]interface{}, 0, len(rawData))
		for _, raw := range rawData {
			var resource bootconfiguration.BootConfiguration
			if err := json.Unmarshal(raw, &resource); err != nil {
				return nil, fmt.Errorf("failed to unmarshal BootConfiguration: %w", err)
			}
			result = append(result, &resource)
		}
		return result, nil
	case "Node":
		result := make([]interface{}, 0, len(rawData))
		for _, raw := range rawData {
			var resource node.Node
			if err := json.Unmarshal(raw, &resource); err != nil {
				return nil, fmt.Errorf("failed to unmarshal Node: %w", err)
			}
			result = append(result, &resource)
		}
		return result, nil
	default:
		return nil, fmt.Errorf("unknown resource kind: %s", kind)
	}
}

// Update updates an existing resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - resource: The resource to update
//
// Returns:
//   - error: Any error that occurred
func (c *StorageClient) Update(ctx context.Context, resource interface{}) error {
	data, err := json.Marshal(resource)
	if err != nil {
		return fmt.Errorf("failed to marshal resource: %w", err)
	}

	// Extract kind and UID based on type
	switch res := resource.(type) {
	case *bmc.BMC:
		return c.backend.Save(ctx, "BMC", res.Metadata.UID, data)
	case *bootconfiguration.BootConfiguration:
		return c.backend.Save(ctx, "BootConfiguration", res.Metadata.UID, data)
	case *node.Node:
		return c.backend.Save(ctx, "Node", res.Metadata.UID, data)
	default:
		return fmt.Errorf("unknown resource type: %T", resource)
	}
}

// Create creates a new resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - resource: The resource to create
//
// Returns:
//   - error: Any error that occurred
func (c *StorageClient) Create(ctx context.Context, resource interface{}) error {
	// For storage backend, Create is the same as Update (Save handles both)
	return c.Update(ctx, resource)
}

// Delete deletes a resource by kind and UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - kind: Resource kind
//   - uid: Unique identifier
//
// Returns:
//   - error: Any error that occurred
func (c *StorageClient) Delete(ctx context.Context, kind, uid string) error {
	return c.backend.Delete(ctx, kind, uid)
}
