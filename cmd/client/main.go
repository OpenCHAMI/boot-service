// Code generated by codegen. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file provides a Cobra-based CLI for the boot_service API.
// Generated from: pkg/codegen/templates/client-cmd.go.tmpl
//
// To modify the CLI:
//  1. Edit the template file: pkg/codegen/templates/client-cmd.go.tmpl
//  2. Run 'make generate-client-cmd' to regenerate
//  3. Do NOT edit this file directly - changes will be lost
//
// Generated commands for each resource:
//   - client bmc [list|get|create|update|patch|delete]
//   - client bootconfiguration [list|get|create|update|patch|delete]
//   - client node [list|get|create|update|patch|delete]
//
// Global flags (available for all commands):
//
//	--server       Server URL (env: BOOT_SERVICE_SERVER)
//	--timeout      Request timeout (env: BOOT_SERVICE_TIMEOUT)
//	--output, -o   Output format: table, json, yaml (env: BOOT_SERVICE_OUTPUT)
//	--version, -v  API version to request: v1, v2beta1, etc. (env: BOOT_SERVICE_VERSION)
//	--config       Config file path (default: ~/.boot_service-cli.yaml)
//
// Configuration sources (in order of precedence):
//  1. Command-line flags
//  2. Environment variables (BOOT_SERVICE_*)
//  3. Config file (~/.boot_service-cli.yaml)
//  4. Default values
//
// Usage examples:
//
//	# List all bmcs (default version)
//	client bmc list
//
//	# List bmcs with specific version
//	client bmc list --version v2beta1
//
//	# Get BMC as v1
//	client bmc get <uid> --version v1
//
//	# Create from JSON file with version
//	cat bmc.json | client bmc create --version v2beta1
//
//	# Create from inline JSON
//	client bmc create --spec '{"name":"bmc-01","description":"Example BMC"}'
//
//	# Use environment variables
//	export BOOT_SERVICE_SERVER=https://boot_service.example.com
//	export BOOT_SERVICE_VERSION=v2beta1
//	client bmc list
//
// To add custom commands:
//  1. Add command definition in template after resource commands
//  2. Register it in init() function
//
// To change output formatting:
//  1. Modify printOutput function to add new formats
//  2. Update output flag validation
//
// To add authentication:
//  1. Add auth flags (--token, --username, etc.)
//  2. Modify getClient to configure auth in http.Client
//  3. Add auth headers in client package
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/openchami/boot-service/pkg/client"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	cfgFile    string
	serverURL  string
	timeout    time.Duration
	output     string
	apiVersion string
)

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

var rootCmd = &cobra.Command{
	Use:   filepath.Base(os.Args[0]),
	Short: "boot_service CLI",
	Long:  `A command-line interface for managing boot_service resources.`,
}

func init() {
	cobra.OnInitialize(initConfig)

	// Global flags
	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is $HOME/.boot_service-cli.yaml)")
	rootCmd.PersistentFlags().StringVar(&serverURL, "server", "http://localhost:8080", "boot_service server URL")
	rootCmd.PersistentFlags().DurationVar(&timeout, "timeout", 30*time.Second, "request timeout")
	rootCmd.PersistentFlags().StringVarP(&output, "output", "o", "table", "output format: table, json, yaml")
	rootCmd.PersistentFlags().StringVarP(&apiVersion, "version", "v", "", "API version to request (e.g., v1, v2beta1)")

	// Bind flags to viper
	viper.BindPFlag("server", rootCmd.PersistentFlags().Lookup("server"))
	viper.BindPFlag("timeout", rootCmd.PersistentFlags().Lookup("timeout"))
	viper.BindPFlag("output", rootCmd.PersistentFlags().Lookup("output"))
	viper.BindPFlag("version", rootCmd.PersistentFlags().Lookup("version"))

	// Environment variable support
	viper.SetEnvPrefix("BOOT_SERVICE")
	viper.AutomaticEnv()

	// Add resource commands
	rootCmd.AddCommand(bmcCmd)
	rootCmd.AddCommand(bootconfigurationCmd)
	rootCmd.AddCommand(nodeCmd)

}

func initConfig() {
	if cfgFile != "" {
		viper.SetConfigFile(cfgFile)
	} else {
		home, err := os.UserHomeDir()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: %v\n", err)
			return
		}

		viper.AddConfigPath(home)
		viper.SetConfigType("yaml")
		viper.SetConfigName(".boot_service-cli")
	}

	if err := viper.ReadInConfig(); err == nil {
		fmt.Fprintln(os.Stderr, "Using config file:", viper.ConfigFileUsed())
	}
}

func getClient() (*client.Client, error) {
	serverURL := viper.GetString("server")
	c, err := client.NewClient(serverURL, nil)
	if err != nil {
		return nil, err
	}

	// Apply version if specified
	version := viper.GetString("version")
	if version != "" {
		c = c.WithVersion(version)
	}

	return c, nil
}

func printOutput(data interface{}) error {
	switch output {
	case "json":
		encoder := json.NewEncoder(os.Stdout)
		encoder.SetIndent("", "  ")
		return encoder.Encode(data)
	case "yaml":
		// TODO: Add YAML support if needed
		return fmt.Errorf("YAML output not yet implemented")
	case "table":
		// Simple table output
		encoder := json.NewEncoder(os.Stdout)
		encoder.SetIndent("", "  ")
		return encoder.Encode(data)
	default:
		return fmt.Errorf("unknown output format: %s", output)
	}
}

// setNestedField sets a field in a nested map using dot notation
// Example: setNestedField(map, "status.health", "OK") sets map["status"]["health"] = "OK"
func setNestedField(target map[string]interface{}, path string, value interface{}) {
	parts := strings.Split(path, ".")
	current := target

	// Navigate to the parent of the target field
	for _, part := range parts[:len(parts)-1] {
		if current[part] == nil {
			current[part] = make(map[string]interface{})
		}
		if nested, ok := current[part].(map[string]interface{}); ok {
			current = nested
		} else {
			// Convert to map if it's not already
			current[part] = make(map[string]interface{})
			current = current[part].(map[string]interface{})
		}
	}

	// Set the final field
	finalField := parts[len(parts)-1]
	if value == nil {
		// For unset operations, we use JSON Merge Patch null semantics
		current[finalField] = nil
	} else if stringValue, ok := value.(string); ok {
		// Try to parse as JSON first, then as string
		var jsonValue interface{}
		if err := json.Unmarshal([]byte(stringValue), &jsonValue); err == nil {
			current[finalField] = jsonValue
		} else {
			current[finalField] = stringValue
		}
	} else {
		current[finalField] = value
	}
}

// BMC commands
var bmcCmd = &cobra.Command{
	Use:   "bmc",
	Short: "Manage bmcs",
	Long:  `Create, read, update, patch, and delete bmcs.`,
}

var bmcListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all bmcs",
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		items, err := c.GetBMCs(ctx)
		if err != nil {
			return fmt.Errorf("failed to list bmcs: %w", err)
		}

		return printOutput(items)
	},
}

var bmcGetCmd = &cobra.Command{
	Use:   "get [uid]",
	Short: "Get a BMC by UID",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.GetBMC(ctx, args[0])
		if err != nil {
			return fmt.Errorf("failed to get BMC: %w", err)
		}

		return printOutput(item)
	},
}

var bmcCreateCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new BMC",
	Long: `Create a new BMC.

Examples:
  # Create from stdin
  echo '{"xname": "example-name", "description": "Example description", "interface": "{}"}' | client bmc create

  # Create with --spec flag
  client bmc create --spec '{"xname": "example-name", "description": "Example description", "interface": "{}"}'

Spec fields:
  xname (string)
  description (string)
  interface (bmc.Interface)
`,
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.CreateBMCRequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.CreateBMC(ctx, req)
		if err != nil {
			return fmt.Errorf("failed to create BMC: %w", err)
		}

		return printOutput(item)
	},
}

var bmcUpdateCmd = &cobra.Command{
	Use:   "update [uid]",
	Short: "Update an existing BMC",
	Long: `Update an existing BMC.

Examples:
  # Update from stdin
  echo '{"xname": "example-name", "description": "Example description", "interface": "{}"}' | client bmc update <uid>

  # Update with --spec flag
  client bmc update <uid> --spec '{"xname": "example-name", "description": "Example description", "interface": "{}"}'

Spec fields:
  xname (string)
  description (string)
  interface (bmc.Interface)
`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.UpdateBMCRequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.UpdateBMC(ctx, args[0], req)
		if err != nil {
			return fmt.Errorf("failed to update BMC: %w", err)
		}

		return printOutput(item)
	},
}

var bmcPatchCmd = &cobra.Command{
	Use:   "patch [uid]",
	Short: "Patch a BMC",
	Long: `Patch an existing BMC spec using various patch formats.

IMPORTANT: Only the spec portion of the resource can be patched.
Metadata (name, labels, annotations) and status are managed by the API.

Examples:
  # JSON Merge Patch (simple merge) - patch spec fields
  client bmc patch <uid> --spec '{"manufacturer":"Intel","model":"Updated Model"}'

  # Shorthand patch (dot notation - most convenient)
  client bmc patch <uid> --set manufacturer=Intel --set model="Updated Model" --unset customField

  # JSON Patch (RFC 6902 - most powerful)
  client bmc patch <uid> --json-patch '[
    {"op":"replace","path":"/manufacturer","value":"Intel"},
    {"op":"add","path":"/properties/newField","value":"newValue"}
  ]'

  # From stdin (JSON Merge Patch format)
  echo '{"manufacturer":"AMD","partNumber":"RYZEN-9000"}' | client bmc patch <uid>

Patch Formats:
  --spec        JSON Merge Patch (RFC 7386) - simple object merge
  --set/--unset Shorthand patch - dot notation for convenience
  --json-patch  JSON Patch (RFC 6902) - operation-based patches
  stdin         JSON Merge Patch format

Shorthand Operations (spec fields only):
  --set field=value     Set a spec field value (supports dot notation)
  --unset field         Remove a spec field (supports dot notation)
  --add field=value     Add to spec array field (field must end with '.-')
  --remove field=value  Remove from spec array field

Note: All patch operations target the resource spec only.
Attempts to patch metadata or status fields will be ignored.`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		uid := args[0]

		// Get patch flags
		specPatch, _ := cmd.Flags().GetString("spec")
		jsonPatch, _ := cmd.Flags().GetString("json-patch")
		setPairs, _ := cmd.Flags().GetStringArray("set")
		unsetFields, _ := cmd.Flags().GetStringArray("unset")
		addPairs, _ := cmd.Flags().GetStringArray("add")
		removePairs, _ := cmd.Flags().GetStringArray("remove")

		var patchData []byte
		var contentType string

		// Determine patch format and build patch data
		if jsonPatch != "" {
			// JSON Patch (RFC 6902)
			patchData = []byte(jsonPatch)
			contentType = "application/json-patch+json"
		} else if len(setPairs) > 0 || len(unsetFields) > 0 || len(addPairs) > 0 || len(removePairs) > 0 {
			// Shorthand patch - convert to JSON Merge Patch
			patch := make(map[string]interface{})

			// Process --set flags
			for _, setPair := range setPairs {
				parts := strings.SplitN(setPair, "=", 2)
				if len(parts) != 2 {
					return fmt.Errorf("invalid --set format: %s (expected field=value)", setPair)
				}
				setNestedField(patch, parts[0], parts[1])
			}

			// Process --unset flags
			for _, field := range unsetFields {
				setNestedField(patch, field, nil)
			}

			// Process --add flags (add to arrays)
			for _, addPair := range addPairs {
				parts := strings.SplitN(addPair, "=", 2)
				if len(parts) != 2 {
					return fmt.Errorf("invalid --add format: %s (expected field=value)", addPair)
				}
				// For arrays, we'll use JSON Merge Patch append syntax if possible
				// Otherwise convert to JSON Patch
				setNestedField(patch, parts[0], parts[1])
			}

			// Process --remove flags
			for _, removePair := range removePairs {
				parts := strings.SplitN(removePair, "=", 2)
				if len(parts) != 2 {
					return fmt.Errorf("invalid --remove format: %s (expected field=value)", removePair)
				}
				// Remove operations are complex and might need JSON Patch
				// For now, we'll handle simple cases
				return fmt.Errorf("--remove operations require --json-patch format")
			}

			patchBytes, err := json.Marshal(patch)
			if err != nil {
				return fmt.Errorf("failed to marshal shorthand patch: %w", err)
			}
			patchData = patchBytes
			contentType = "application/merge-patch+json"
		} else if specPatch != "" {
			// JSON Merge Patch from --spec
			patchData = []byte(specPatch)
			contentType = "application/merge-patch+json"
		} else {
			// Read from stdin (default to JSON Merge Patch)
			decoder := json.NewDecoder(os.Stdin)
			var patch interface{}
			if err := decoder.Decode(&patch); err != nil {
				return fmt.Errorf("failed to decode patch from stdin: %w", err)
			}
			patchBytes, err := json.Marshal(patch)
			if err != nil {
				return fmt.Errorf("failed to marshal patch: %w", err)
			}
			patchData = patchBytes
			contentType = "application/merge-patch+json"
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.PatchBMC(ctx, uid, patchData, contentType)
		if err != nil {
			return fmt.Errorf("failed to patch BMC: %w", err)
		}

		return printOutput(item)
	},
}

var bmcDeleteCmd = &cobra.Command{
	Use:   "delete [uid]",
	Short: "Delete a BMC",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		if err := c.DeleteBMC(ctx, args[0]); err != nil {
			return fmt.Errorf("failed to delete BMC: %w", err)
		}

		fmt.Printf("BMC %s deleted successfully\n", args[0])
		return nil
	},
}

func init() {
	bmcCmd.AddCommand(bmcListCmd)
	bmcCmd.AddCommand(bmcGetCmd)
	bmcCmd.AddCommand(bmcCreateCmd)
	bmcCmd.AddCommand(bmcUpdateCmd)
	bmcCmd.AddCommand(bmcPatchCmd)
	bmcCmd.AddCommand(bmcDeleteCmd)

	// Add spec flag for create and update commands
	bmcCreateCmd.Flags().String("spec", "", "BMC specification in JSON format")
	bmcUpdateCmd.Flags().String("spec", "", "BMC specification in JSON format")

	// Add patch command flags
	bmcPatchCmd.Flags().String("spec", "", "JSON Merge Patch specification")
	bmcPatchCmd.Flags().String("json-patch", "", "JSON Patch operations (RFC 6902)")
	bmcPatchCmd.Flags().StringArray("set", nil, "Set field value using dot notation (field=value)")
	bmcPatchCmd.Flags().StringArray("unset", nil, "Unset field using dot notation")
	bmcPatchCmd.Flags().StringArray("add", nil, "Add value to array field (field=value)")
	bmcPatchCmd.Flags().StringArray("remove", nil, "Remove value from array field (field=value)")
}

// BootConfiguration commands
var bootconfigurationCmd = &cobra.Command{
	Use:   "bootconfiguration",
	Short: "Manage bootconfigurations",
	Long:  `Create, read, update, patch, and delete bootconfigurations.`,
}

var bootconfigurationListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all bootconfigurations",
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		items, err := c.GetBootConfigurations(ctx)
		if err != nil {
			return fmt.Errorf("failed to list bootconfigurations: %w", err)
		}

		return printOutput(items)
	},
}

var bootconfigurationGetCmd = &cobra.Command{
	Use:   "get [uid]",
	Short: "Get a BootConfiguration by UID",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.GetBootConfiguration(ctx, args[0])
		if err != nil {
			return fmt.Errorf("failed to get BootConfiguration: %w", err)
		}

		return printOutput(item)
	},
}

var bootconfigurationCreateCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new BootConfiguration",
	Long: `Create a new BootConfiguration.

Examples:
  # Create from stdin
  echo '{"hosts": ["["item1","item2"]"], "macs": ["["item1","item2"]"], "nids": [], "groups": ["["item1","item2"]"], "kernel": "example-value", "initrd": "example-value", "params": "example-value", "priority": 42}' | client bootconfiguration create

  # Create with --spec flag
  client bootconfiguration create --spec '{"hosts": ["["item1","item2"]"], "macs": ["["item1","item2"]"], "nids": [], "groups": ["["item1","item2"]"], "kernel": "example-value", "initrd": "example-value", "params": "example-value", "priority": 42}'

Spec fields:
  hosts ([]string)
  macs ([]string)
  nids ([]int32)
  groups ([]string)
  kernel (string)
  initrd (string)
  params (string)
  priority (int)
`,
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.CreateBootConfigurationRequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.CreateBootConfiguration(ctx, req)
		if err != nil {
			return fmt.Errorf("failed to create BootConfiguration: %w", err)
		}

		return printOutput(item)
	},
}

var bootconfigurationUpdateCmd = &cobra.Command{
	Use:   "update [uid]",
	Short: "Update an existing BootConfiguration",
	Long: `Update an existing BootConfiguration.

Examples:
  # Update from stdin
  echo '{"hosts": ["["item1","item2"]"], "macs": ["["item1","item2"]"], "nids": [], "groups": ["["item1","item2"]"], "kernel": "example-value", "initrd": "example-value", "params": "example-value", "priority": 42}' | client bootconfiguration update <uid>

  # Update with --spec flag
  client bootconfiguration update <uid> --spec '{"hosts": ["["item1","item2"]"], "macs": ["["item1","item2"]"], "nids": [], "groups": ["["item1","item2"]"], "kernel": "example-value", "initrd": "example-value", "params": "example-value", "priority": 42}'

Spec fields:
  hosts ([]string)
  macs ([]string)
  nids ([]int32)
  groups ([]string)
  kernel (string)
  initrd (string)
  params (string)
  priority (int)
`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.UpdateBootConfigurationRequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.UpdateBootConfiguration(ctx, args[0], req)
		if err != nil {
			return fmt.Errorf("failed to update BootConfiguration: %w", err)
		}

		return printOutput(item)
	},
}

var bootconfigurationPatchCmd = &cobra.Command{
	Use:   "patch [uid]",
	Short: "Patch a BootConfiguration",
	Long: `Patch an existing BootConfiguration spec using various patch formats.

IMPORTANT: Only the spec portion of the resource can be patched.
Metadata (name, labels, annotations) and status are managed by the API.

Examples:
  # JSON Merge Patch (simple merge) - patch spec fields
  client bootconfiguration patch <uid> --spec '{"manufacturer":"Intel","model":"Updated Model"}'

  # Shorthand patch (dot notation - most convenient)
  client bootconfiguration patch <uid> --set manufacturer=Intel --set model="Updated Model" --unset customField

  # JSON Patch (RFC 6902 - most powerful)
  client bootconfiguration patch <uid> --json-patch '[
    {"op":"replace","path":"/manufacturer","value":"Intel"},
    {"op":"add","path":"/properties/newField","value":"newValue"}
  ]'

  # From stdin (JSON Merge Patch format)
  echo '{"manufacturer":"AMD","partNumber":"RYZEN-9000"}' | client bootconfiguration patch <uid>

Patch Formats:
  --spec        JSON Merge Patch (RFC 7386) - simple object merge
  --set/--unset Shorthand patch - dot notation for convenience
  --json-patch  JSON Patch (RFC 6902) - operation-based patches
  stdin         JSON Merge Patch format

Shorthand Operations (spec fields only):
  --set field=value     Set a spec field value (supports dot notation)
  --unset field         Remove a spec field (supports dot notation)
  --add field=value     Add to spec array field (field must end with '.-')
  --remove field=value  Remove from spec array field

Note: All patch operations target the resource spec only.
Attempts to patch metadata or status fields will be ignored.`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		uid := args[0]

		// Get patch flags
		specPatch, _ := cmd.Flags().GetString("spec")
		jsonPatch, _ := cmd.Flags().GetString("json-patch")
		setPairs, _ := cmd.Flags().GetStringArray("set")
		unsetFields, _ := cmd.Flags().GetStringArray("unset")
		addPairs, _ := cmd.Flags().GetStringArray("add")
		removePairs, _ := cmd.Flags().GetStringArray("remove")

		var patchData []byte
		var contentType string

		// Determine patch format and build patch data
		if jsonPatch != "" {
			// JSON Patch (RFC 6902)
			patchData = []byte(jsonPatch)
			contentType = "application/json-patch+json"
		} else if len(setPairs) > 0 || len(unsetFields) > 0 || len(addPairs) > 0 || len(removePairs) > 0 {
			// Shorthand patch - convert to JSON Merge Patch
			patch := make(map[string]interface{})

			// Process --set flags
			for _, setPair := range setPairs {
				parts := strings.SplitN(setPair, "=", 2)
				if len(parts) != 2 {
					return fmt.Errorf("invalid --set format: %s (expected field=value)", setPair)
				}
				setNestedField(patch, parts[0], parts[1])
			}

			// Process --unset flags
			for _, field := range unsetFields {
				setNestedField(patch, field, nil)
			}

			// Process --add flags (add to arrays)
			for _, addPair := range addPairs {
				parts := strings.SplitN(addPair, "=", 2)
				if len(parts) != 2 {
					return fmt.Errorf("invalid --add format: %s (expected field=value)", addPair)
				}
				// For arrays, we'll use JSON Merge Patch append syntax if possible
				// Otherwise convert to JSON Patch
				setNestedField(patch, parts[0], parts[1])
			}

			// Process --remove flags
			for _, removePair := range removePairs {
				parts := strings.SplitN(removePair, "=", 2)
				if len(parts) != 2 {
					return fmt.Errorf("invalid --remove format: %s (expected field=value)", removePair)
				}
				// Remove operations are complex and might need JSON Patch
				// For now, we'll handle simple cases
				return fmt.Errorf("--remove operations require --json-patch format")
			}

			patchBytes, err := json.Marshal(patch)
			if err != nil {
				return fmt.Errorf("failed to marshal shorthand patch: %w", err)
			}
			patchData = patchBytes
			contentType = "application/merge-patch+json"
		} else if specPatch != "" {
			// JSON Merge Patch from --spec
			patchData = []byte(specPatch)
			contentType = "application/merge-patch+json"
		} else {
			// Read from stdin (default to JSON Merge Patch)
			decoder := json.NewDecoder(os.Stdin)
			var patch interface{}
			if err := decoder.Decode(&patch); err != nil {
				return fmt.Errorf("failed to decode patch from stdin: %w", err)
			}
			patchBytes, err := json.Marshal(patch)
			if err != nil {
				return fmt.Errorf("failed to marshal patch: %w", err)
			}
			patchData = patchBytes
			contentType = "application/merge-patch+json"
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.PatchBootConfiguration(ctx, uid, patchData, contentType)
		if err != nil {
			return fmt.Errorf("failed to patch BootConfiguration: %w", err)
		}

		return printOutput(item)
	},
}

var bootconfigurationDeleteCmd = &cobra.Command{
	Use:   "delete [uid]",
	Short: "Delete a BootConfiguration",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		if err := c.DeleteBootConfiguration(ctx, args[0]); err != nil {
			return fmt.Errorf("failed to delete BootConfiguration: %w", err)
		}

		fmt.Printf("BootConfiguration %s deleted successfully\n", args[0])
		return nil
	},
}

func init() {
	bootconfigurationCmd.AddCommand(bootconfigurationListCmd)
	bootconfigurationCmd.AddCommand(bootconfigurationGetCmd)
	bootconfigurationCmd.AddCommand(bootconfigurationCreateCmd)
	bootconfigurationCmd.AddCommand(bootconfigurationUpdateCmd)
	bootconfigurationCmd.AddCommand(bootconfigurationPatchCmd)
	bootconfigurationCmd.AddCommand(bootconfigurationDeleteCmd)

	// Add spec flag for create and update commands
	bootconfigurationCreateCmd.Flags().String("spec", "", "BootConfiguration specification in JSON format")
	bootconfigurationUpdateCmd.Flags().String("spec", "", "BootConfiguration specification in JSON format")

	// Add patch command flags
	bootconfigurationPatchCmd.Flags().String("spec", "", "JSON Merge Patch specification")
	bootconfigurationPatchCmd.Flags().String("json-patch", "", "JSON Patch operations (RFC 6902)")
	bootconfigurationPatchCmd.Flags().StringArray("set", nil, "Set field value using dot notation (field=value)")
	bootconfigurationPatchCmd.Flags().StringArray("unset", nil, "Unset field using dot notation")
	bootconfigurationPatchCmd.Flags().StringArray("add", nil, "Add value to array field (field=value)")
	bootconfigurationPatchCmd.Flags().StringArray("remove", nil, "Remove value from array field (field=value)")
}

// Node commands
var nodeCmd = &cobra.Command{
	Use:   "node",
	Short: "Manage nodes",
	Long:  `Create, read, update, patch, and delete nodes.`,
}

var nodeListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all nodes",
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		items, err := c.GetNodes(ctx)
		if err != nil {
			return fmt.Errorf("failed to list nodes: %w", err)
		}

		return printOutput(items)
	},
}

var nodeGetCmd = &cobra.Command{
	Use:   "get [uid]",
	Short: "Get a Node by UID",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.GetNode(ctx, args[0])
		if err != nil {
			return fmt.Errorf("failed to get Node: %w", err)
		}

		return printOutput(item)
	},
}

var nodeCreateCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new Node",
	Long: `Create a new Node.

Examples:
  # Create from stdin
  echo '{"xname": "example-name", "nid": 42, "bootMac": "example-value", "role": "example-value", "subRole": "example-value", "hostname": "example-name", "interfaces": ["[]"], "groups": ["["item1","item2"]"]}' | client node create

  # Create with --spec flag
  client node create --spec '{"xname": "example-name", "nid": 42, "bootMac": "example-value", "role": "example-value", "subRole": "example-value", "hostname": "example-name", "interfaces": ["[]"], "groups": ["["item1","item2"]"]}'

Spec fields:
  xname (string)
  nid (int32)
  bootMac (string)
  role (string)
  subRole (string)
  hostname (string)
  interfaces ([]node.Interface)
  groups ([]string)
`,
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.CreateNodeRequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.CreateNode(ctx, req)
		if err != nil {
			return fmt.Errorf("failed to create Node: %w", err)
		}

		return printOutput(item)
	},
}

var nodeUpdateCmd = &cobra.Command{
	Use:   "update [uid]",
	Short: "Update an existing Node",
	Long: `Update an existing Node.

Examples:
  # Update from stdin
  echo '{"xname": "example-name", "nid": 42, "bootMac": "example-value", "role": "example-value", "subRole": "example-value", "hostname": "example-name", "interfaces": ["[]"], "groups": ["["item1","item2"]"]}' | client node update <uid>

  # Update with --spec flag
  client node update <uid> --spec '{"xname": "example-name", "nid": 42, "bootMac": "example-value", "role": "example-value", "subRole": "example-value", "hostname": "example-name", "interfaces": ["[]"], "groups": ["["item1","item2"]"]}'

Spec fields:
  xname (string)
  nid (int32)
  bootMac (string)
  role (string)
  subRole (string)
  hostname (string)
  interfaces ([]node.Interface)
  groups ([]string)
`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.UpdateNodeRequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.UpdateNode(ctx, args[0], req)
		if err != nil {
			return fmt.Errorf("failed to update Node: %w", err)
		}

		return printOutput(item)
	},
}

var nodePatchCmd = &cobra.Command{
	Use:   "patch [uid]",
	Short: "Patch a Node",
	Long: `Patch an existing Node spec using various patch formats.

IMPORTANT: Only the spec portion of the resource can be patched.
Metadata (name, labels, annotations) and status are managed by the API.

Examples:
  # JSON Merge Patch (simple merge) - patch spec fields
  client node patch <uid> --spec '{"manufacturer":"Intel","model":"Updated Model"}'

  # Shorthand patch (dot notation - most convenient)
  client node patch <uid> --set manufacturer=Intel --set model="Updated Model" --unset customField

  # JSON Patch (RFC 6902 - most powerful)
  client node patch <uid> --json-patch '[
    {"op":"replace","path":"/manufacturer","value":"Intel"},
    {"op":"add","path":"/properties/newField","value":"newValue"}
  ]'

  # From stdin (JSON Merge Patch format)
  echo '{"manufacturer":"AMD","partNumber":"RYZEN-9000"}' | client node patch <uid>

Patch Formats:
  --spec        JSON Merge Patch (RFC 7386) - simple object merge
  --set/--unset Shorthand patch - dot notation for convenience
  --json-patch  JSON Patch (RFC 6902) - operation-based patches
  stdin         JSON Merge Patch format

Shorthand Operations (spec fields only):
  --set field=value     Set a spec field value (supports dot notation)
  --unset field         Remove a spec field (supports dot notation)
  --add field=value     Add to spec array field (field must end with '.-')
  --remove field=value  Remove from spec array field

Note: All patch operations target the resource spec only.
Attempts to patch metadata or status fields will be ignored.`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		uid := args[0]

		// Get patch flags
		specPatch, _ := cmd.Flags().GetString("spec")
		jsonPatch, _ := cmd.Flags().GetString("json-patch")
		setPairs, _ := cmd.Flags().GetStringArray("set")
		unsetFields, _ := cmd.Flags().GetStringArray("unset")
		addPairs, _ := cmd.Flags().GetStringArray("add")
		removePairs, _ := cmd.Flags().GetStringArray("remove")

		var patchData []byte
		var contentType string

		// Determine patch format and build patch data
		if jsonPatch != "" {
			// JSON Patch (RFC 6902)
			patchData = []byte(jsonPatch)
			contentType = "application/json-patch+json"
		} else if len(setPairs) > 0 || len(unsetFields) > 0 || len(addPairs) > 0 || len(removePairs) > 0 {
			// Shorthand patch - convert to JSON Merge Patch
			patch := make(map[string]interface{})

			// Process --set flags
			for _, setPair := range setPairs {
				parts := strings.SplitN(setPair, "=", 2)
				if len(parts) != 2 {
					return fmt.Errorf("invalid --set format: %s (expected field=value)", setPair)
				}
				setNestedField(patch, parts[0], parts[1])
			}

			// Process --unset flags
			for _, field := range unsetFields {
				setNestedField(patch, field, nil)
			}

			// Process --add flags (add to arrays)
			for _, addPair := range addPairs {
				parts := strings.SplitN(addPair, "=", 2)
				if len(parts) != 2 {
					return fmt.Errorf("invalid --add format: %s (expected field=value)", addPair)
				}
				// For arrays, we'll use JSON Merge Patch append syntax if possible
				// Otherwise convert to JSON Patch
				setNestedField(patch, parts[0], parts[1])
			}

			// Process --remove flags
			for _, removePair := range removePairs {
				parts := strings.SplitN(removePair, "=", 2)
				if len(parts) != 2 {
					return fmt.Errorf("invalid --remove format: %s (expected field=value)", removePair)
				}
				// Remove operations are complex and might need JSON Patch
				// For now, we'll handle simple cases
				return fmt.Errorf("--remove operations require --json-patch format")
			}

			patchBytes, err := json.Marshal(patch)
			if err != nil {
				return fmt.Errorf("failed to marshal shorthand patch: %w", err)
			}
			patchData = patchBytes
			contentType = "application/merge-patch+json"
		} else if specPatch != "" {
			// JSON Merge Patch from --spec
			patchData = []byte(specPatch)
			contentType = "application/merge-patch+json"
		} else {
			// Read from stdin (default to JSON Merge Patch)
			decoder := json.NewDecoder(os.Stdin)
			var patch interface{}
			if err := decoder.Decode(&patch); err != nil {
				return fmt.Errorf("failed to decode patch from stdin: %w", err)
			}
			patchBytes, err := json.Marshal(patch)
			if err != nil {
				return fmt.Errorf("failed to marshal patch: %w", err)
			}
			patchData = patchBytes
			contentType = "application/merge-patch+json"
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.PatchNode(ctx, uid, patchData, contentType)
		if err != nil {
			return fmt.Errorf("failed to patch Node: %w", err)
		}

		return printOutput(item)
	},
}

var nodeDeleteCmd = &cobra.Command{
	Use:   "delete [uid]",
	Short: "Delete a Node",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		if err := c.DeleteNode(ctx, args[0]); err != nil {
			return fmt.Errorf("failed to delete Node: %w", err)
		}

		fmt.Printf("Node %s deleted successfully\n", args[0])
		return nil
	},
}

func init() {
	nodeCmd.AddCommand(nodeListCmd)
	nodeCmd.AddCommand(nodeGetCmd)
	nodeCmd.AddCommand(nodeCreateCmd)
	nodeCmd.AddCommand(nodeUpdateCmd)
	nodeCmd.AddCommand(nodePatchCmd)
	nodeCmd.AddCommand(nodeDeleteCmd)

	// Add spec flag for create and update commands
	nodeCreateCmd.Flags().String("spec", "", "Node specification in JSON format")
	nodeUpdateCmd.Flags().String("spec", "", "Node specification in JSON format")

	// Add patch command flags
	nodePatchCmd.Flags().String("spec", "", "JSON Merge Patch specification")
	nodePatchCmd.Flags().String("json-patch", "", "JSON Patch operations (RFC 6902)")
	nodePatchCmd.Flags().StringArray("set", nil, "Set field value using dot notation (field=value)")
	nodePatchCmd.Flags().StringArray("unset", nil, "Unset field using dot notation")
	nodePatchCmd.Flags().StringArray("add", nil, "Add value to array field (field=value)")
	nodePatchCmd.Flags().StringArray("remove", nil, "Remove value from array field (field=value)")
}
