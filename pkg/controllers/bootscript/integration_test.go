package bootscript

import (
	"context"
	"log"
	"net/http"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/openchami/boot-service/pkg/client"
	"github.com/openchami/boot-service/pkg/resources/bootconfiguration"
	"github.com/openchami/boot-service/pkg/resources/node"
)

// These types mirror the server request types for testing
type CreateNodeRequest struct {
	node.NodeSpec `json:",inline"`
	Name          string            `json:"name" validate:"required"`
	Labels        map[string]string `json:"labels,omitempty"`
	Annotations   map[string]string `json:"annotations,omitempty"`
}

type CreateBootConfigurationRequest struct {
	bootconfiguration.BootConfigurationSpec `json:",inline"`
	Name                                    string            `json:"name" validate:"required"`
	Labels                                  map[string]string `json:"labels,omitempty"`
	Annotations                             map[string]string `json:"annotations,omitempty"`
}

// TestBootLogicIntegration provides end-to-end testing of the boot logic
// This test proves that the complete boot script generation workflow works correctly
// NOTE: This test requires a running boot service at localhost:8080
func TestBootLogicIntegration(t *testing.T) {
	// Skip if we're not in integration test mode
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// Create client pointing to localhost (assumes server is running)
	bootClient, err := client.NewClient("http://localhost:8080", &http.Client{Timeout: 30 * time.Second})
	if err != nil {
		t.Fatalf("Failed to create client: %v", err)
	}

	// Create controller with real client
	logger := log.New(os.Stdout, "test: ", log.LstdFlags)
	controller := NewBootScriptController(*bootClient, logger)

	ctx := context.Background()

	// Test server connectivity first
	_, err = bootClient.GetNodes(ctx)
	if err != nil {
		t.Skipf("Boot service not available at localhost:8080, skipping integration test: %v", err)
	}

	// Test Case 1: Create a compute node and matching configuration
	t.Run("Compute Node with Matching Configuration", func(t *testing.T) {
		// Create a compute node using the correct request structure
		nodeReq := CreateNodeRequest{
			NodeSpec: node.NodeSpec{
				XName:    "x1000c0s0b1n0",
				NID:      1001,
				BootMAC:  "aa:bb:cc:dd:01:01",
				Role:     "Compute",
				SubRole:  "Worker",
				Hostname: "compute-001",
				Groups:   []string{"compute", "batch"},
			},
			Name: "compute-001",
		}

		createdNode, err := bootClient.CreateNode(ctx, nodeReq)
		if err != nil {
			t.Fatalf("Failed to create compute node: %v", err)
		}
		t.Logf("Created node: %s (%s)", createdNode.GetName(), createdNode.Spec.XName)

		// Create a matching boot configuration
		configReq := CreateBootConfigurationRequest{
			BootConfigurationSpec: bootconfiguration.BootConfigurationSpec{
				Hosts:    []string{"x1000c0s0b1n0"},
				Kernel:   "http://files.hpc.example.com/compute/vmlinuz-5.15.0",
				Initrd:   "http://files.hpc.example.com/compute/initramfs-5.15.0",
				Params:   "console=ttyS0,115200 root=/dev/ram0 rw",
				Priority: 100,
			},
			Name: "compute-config",
		}

		createdConfig, err := bootClient.CreateBootConfiguration(ctx, configReq)
		if err != nil {
			t.Fatalf("Failed to create compute config: %v", err)
		}
		t.Logf("Created config: %s (priority: %d)", createdConfig.GetName(), createdConfig.Spec.Priority)

		// Test boot script generation by XName
		script, err := controller.GenerateBootScript(ctx, "x1000c0s0b1n0")
		if err != nil {
			t.Fatalf("Failed to generate boot script: %v", err)
		}

		// Validate script content
		validateBootScript(t, script, map[string]string{
			"XName":          "x1000c0s0b1n0",
			"NID":            "1001",
			"BootMAC":        "aa:bb:cc:dd:01:01",
			"Role":           "Compute",
			"Kernel":         "http://files.hpc.example.com/compute/vmlinuz-5.15.0",
			"Initrd":         "http://files.hpc.example.com/compute/initramfs-5.15.0",
			"Params":         "console=ttyS0,115200 root=/dev/ram0 rw",
			"ConfigName":     "compute-config",
			"KernelFilename": "vmlinuz-5.15.0",
			"InitrdFilename": "initramfs-5.15.0",
		})

		// Test boot script generation by NID
		scriptByNID, err := controller.GenerateBootScript(ctx, "1001")
		if err != nil {
			t.Fatalf("Failed to generate boot script by NID: %v", err)
		}

		if script != scriptByNID {
			t.Errorf("Script generated by XName should match script generated by NID")
		}

		// Test boot script generation by MAC
		scriptByMAC, err := controller.GenerateBootScript(ctx, "aa:bb:cc:dd:01:01")
		if err != nil {
			t.Fatalf("Failed to generate boot script by MAC: %v", err)
		}

		if script != scriptByMAC {
			t.Errorf("Script generated by XName should match script generated by MAC")
		}

		t.Logf("✅ Successfully generated consistent boot scripts via XName, NID, and MAC")
	})

	// Test Case 2: Priority-based configuration selection
	t.Run("Priority-Based Configuration Selection", func(t *testing.T) {
		// Create a management node
		mgmtNodeReq := CreateNodeRequest{
			NodeSpec: node.NodeSpec{
				XName:    "x1000c0s0b2n0",
				NID:      2001,
				BootMAC:  "aa:bb:cc:dd:02:01",
				Role:     "Management",
				SubRole:  "Login",
				Hostname: "login-001",
				Groups:   []string{"management", "login"},
			},
			Name: "login-001",
		}

		_, err := bootClient.CreateNode(ctx, mgmtNodeReq)
		if err != nil {
			t.Fatalf("Failed to create management node: %v", err)
		}

		// Create low-priority configuration (matches host)
		lowPriorityReq := CreateBootConfigurationRequest{
			BootConfigurationSpec: bootconfiguration.BootConfigurationSpec{
				Hosts:    []string{"x1000c0s0b2n0"},
				Kernel:   "http://files.hpc.example.com/base/vmlinuz",
				Priority: 25,
			},
			Name: "low-priority-config",
		}

		_, err = bootClient.CreateBootConfiguration(ctx, lowPriorityReq)
		if err != nil {
			t.Fatalf("Failed to create low priority config: %v", err)
		}

		// Create high-priority configuration (matches MAC - higher score)
		highPriorityReq := CreateBootConfigurationRequest{
			BootConfigurationSpec: bootconfiguration.BootConfigurationSpec{
				MACs:     []string{"aa:bb:cc:dd:02:01"},
				Kernel:   "http://files.hpc.example.com/management/vmlinuz",
				Priority: 75,
			},
			Name: "high-priority-config",
		}

		_, err = bootClient.CreateBootConfiguration(ctx, highPriorityReq)
		if err != nil {
			t.Fatalf("Failed to create high priority config: %v", err)
		}

		// Generate boot script - should select high-priority config due to MAC match (100 points)
		script, err := controller.GenerateBootScript(ctx, "x1000c0s0b2n0")
		if err != nil {
			t.Fatalf("Failed to generate boot script: %v", err)
		}

		// Should use the high-priority config due to higher score (MAC match = 100 points vs host match = 50 points)
		if !strings.Contains(script, "management/vmlinuz") {
			t.Errorf("Expected high-priority config to be selected, but got: %s", script)
		}

		t.Logf("✅ Successfully selected high-priority configuration based on scoring algorithm")
	})

	// Test Case 3: Group-based matching
	t.Run("Group-Based Configuration Matching", func(t *testing.T) {
		// Create a GPU compute node
		gpuNodeReq := CreateNodeRequest{
			NodeSpec: node.NodeSpec{
				XName:    "x1000c0s0b3n0",
				NID:      3001,
				BootMAC:  "aa:bb:cc:dd:03:01",
				Role:     "Compute",
				SubRole:  "GPU",
				Hostname: "gpu-001",
				Groups:   []string{"compute", "gpu", "cuda"},
			},
			Name: "gpu-001",
		}

		_, err := bootClient.CreateNode(ctx, gpuNodeReq)
		if err != nil {
			t.Fatalf("Failed to create GPU node: %v", err)
		}

		// Create group-based configuration
		gpuConfigReq := CreateBootConfigurationRequest{
			BootConfigurationSpec: bootconfiguration.BootConfigurationSpec{
				Groups:   []string{"gpu", "cuda"},
				Kernel:   "http://files.hpc.example.com/gpu/vmlinuz-cuda",
				Initrd:   "http://files.hpc.example.com/gpu/initramfs-cuda",
				Params:   "console=ttyS0,115200 nvidia=on",
				Priority: 90,
			},
			Name: "gpu-config",
		}

		_, err = bootClient.CreateBootConfiguration(ctx, gpuConfigReq)
		if err != nil {
			t.Fatalf("Failed to create GPU config: %v", err)
		}

		// Generate boot script
		script, err := controller.GenerateBootScript(ctx, "x1000c0s0b3n0")
		if err != nil {
			t.Fatalf("Failed to generate boot script: %v", err)
		}

		// Validate GPU-specific configuration is used
		validateBootScript(t, script, map[string]string{
			"XName":      "x1000c0s0b3n0",
			"Groups":     "compute,gpu,cuda",
			"Kernel":     "http://files.hpc.example.com/gpu/vmlinuz-cuda",
			"Params":     "console=ttyS0,115200 nvidia=on",
			"ConfigName": "gpu-config",
		})

		t.Logf("✅ Successfully matched configuration based on group membership")
	})

	// Test Case 4: Unknown node handling
	t.Run("Unknown Node Fallback", func(t *testing.T) {
		// Try to generate script for non-existent node
		script, err := controller.GenerateBootScript(ctx, "x9999c9s9b9n9")
		if err != nil {
			t.Fatalf("Expected graceful handling of unknown node, but got error: %v", err)
		}

		// Should return error script
		if !strings.Contains(script, "#!ipxe") {
			t.Errorf("Expected valid iPXE script for unknown node")
		}
		if !strings.Contains(script, "Boot script generation failed") ||
			!strings.Contains(script, "Node resolution failed") {
			t.Errorf("Expected error message in script for unknown node")
		}

		t.Logf("✅ Successfully handled unknown node with error script")
	})

	// Test Case 5: Cache behavior verification
	t.Run("Cache Behavior Validation", func(t *testing.T) {
		// Clear cache statistics
		stats := controller.cache.Stats()
		t.Logf("Cache stats before test - Total: %d, Valid: %d", stats.TotalEntries, stats.ValidEntries)

		// Generate script (should be cache miss)
		start := time.Now()
		script1, err := controller.GenerateBootScript(ctx, "x1000c0s0b1n0")
		duration1 := time.Since(start)
		if err != nil {
			t.Fatalf("Failed to generate boot script: %v", err)
		}

		// Generate same script again (should be cache hit)
		start = time.Now()
		script2, err := controller.GenerateBootScript(ctx, "x1000c0s0b1n0")
		duration2 := time.Since(start)
		if err != nil {
			t.Fatalf("Failed to generate boot script: %v", err)
		}

		// Scripts should be identical
		if script1 != script2 {
			t.Errorf("Cached script should match original script")
		}

		// Cache hit should be faster (though this might be unreliable in tests)
		t.Logf("First generation: %v, Second generation: %v", duration1, duration2)

		// Verify cache statistics
		stats = controller.cache.Stats()
		if stats.ValidEntries == 0 {
			t.Errorf("Expected cache to contain entries")
		}

		t.Logf("✅ Successfully validated cache behavior - entries: %d", stats.ValidEntries)
	})

	t.Logf("🎉 All integration tests passed - boot logic is fully functional!")
}

// validateBootScript checks that the generated script contains expected values
func validateBootScript(t *testing.T, script string, expectedValues map[string]string) {
	t.Helper()

	// Must be valid iPXE script
	if !strings.Contains(script, "#!ipxe") {
		t.Errorf("Script missing iPXE header")
	}

	// Check for required iPXE commands
	requiredCommands := []string{"dhcp", "kernel", "boot"}
	for _, cmd := range requiredCommands {
		if !strings.Contains(script, cmd) {
			t.Errorf("Script missing required iPXE command: %s", cmd)
		}
	}

	// Check expected values are present
	for key, expected := range expectedValues {
		if !strings.Contains(script, expected) {
			t.Errorf("Script missing expected %s: %s\nScript content:\n%s", key, expected, script)
		}
	}

	t.Logf("✅ Boot script validation passed")
}
